[{"class":"android.content.ContextWrapper","api":"clearWallpaper","permissionText":"This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."},{"class":"android.content.ContextWrapper","api":"getExternalCacheDir","permissionText":"The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"getExternalCacheDirs","permissionText":"The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"getExternalFilesDir","permissionText":"Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"getExternalFilesDirs","permissionText":"Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"getExternalMediaDirs","permissionText":"Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"getObbDir","permissionText":"Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"getObbDirs","permissionText":"Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."},{"class":"android.content.ContextWrapper","api":"removeStickyBroadcast","permissionText":"Remove the data previously sent with sendStickyBroadcast(Intent),\n so that it is as if the sticky broadcast had never happened.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"},{"class":"android.content.ContextWrapper","api":"removeStickyBroadcastAsUser","permissionText":"You must hold the Manifest.permission.BROADCAST_STICKY\n permission in order to use this API.  If you do not hold that\n permission, SecurityException will be thrown.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"},{"class":"android.content.ContextWrapper","api":"sendBroadcastAsUser","permissionText":"Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"},{"class":"android.content.ContextWrapper","api":"sendBroadcastAsUser","permissionText":"Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"},{"class":"android.content.ContextWrapper","api":"sendOrderedBroadcastAsUser","permissionText":"See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"},{"class":"android.content.ContextWrapper","api":"sendStickyBroadcast","permissionText":"Perform a sendBroadcast(android.content.Intent) that is \"sticky,\" meaning the\n Intent you are sending stays around after the broadcast is complete,\n so that others can quickly retrieve that data through the return\n value of registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter).  In\n all other ways, this behaves the same as\n sendBroadcast(android.content.Intent).\n\n \n Requires Manifest.permission.BROADCAST_STICKY"},{"class":"android.content.ContextWrapper","api":"sendStickyBroadcastAsUser","permissionText":"Version of sendStickyBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"},{"class":"android.content.ContextWrapper","api":"sendStickyOrderedBroadcast","permissionText":"See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"},{"class":"android.content.ContextWrapper","api":"sendStickyOrderedBroadcastAsUser","permissionText":"See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"},{"class":"android.content.ContextWrapper","api":"setWallpaper","permissionText":"This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."},{"class":"android.content.ContextWrapper","api":"setWallpaper","permissionText":"This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."},{"class":"android.telephony.SmsManager","api":"getSmsMessagesForFinancialApp","permissionText":"Manifest.permission.SMS_FINANCIAL_TRANSACTIONS"},{"class":"android.telephony.SmsManager","api":"injectSmsPdu","permissionText":"Requires permission: Manifest.permission.MODIFY_PHONE_STATE or carrier\n privileges per TelephonyManager.hasCarrierPrivileges()."},{"class":"android.telephony.SmsManager","api":"sendDataMessage","permissionText":"Note: Using this method requires that your app has the\n Manifest.permission.SEND_SMS permission."},{"class":"android.telephony.SmsManager","api":"sendMultipartTextMessage","permissionText":"Note: Using this method requires that your app has the\n Manifest.permission.SEND_SMS permission."},{"class":"android.telephony.SmsManager","api":"sendTextMessage","permissionText":"Note: Using this method requires that your app has the\n Manifest.permission.SEND_SMS permission."},{"class":"android.telephony.SmsManager","api":"sendTextMessageWithoutPersisting","permissionText":"Requires Permission: Both Manifest.permission.SEND_SMS and\n Manifest.permission.MODIFY_PHONE_STATE, or that the calling app has carrier\n privileges (see TelephonyManager#hasCarrierPrivileges), or that the calling app is\n the default IMS app (see\n CarrierConfigManager#KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING)."},{"class":"android.content.pm.PackageManager","api":"canRequestPackageInstalls","permissionText":"Checks whether the calling package is allowed to request package installs through package\n installer. Apps are encouraged to call this API before launching the package installer via\n intent Intent.ACTION_INSTALL_PACKAGE. Starting from Android O, the\n user can explicitly choose what external sources they trust to install apps on the device.\n If this API returns false, the install request will be blocked by the package installer and\n a dialog will be shown to the user with an option to launch settings to change their\n preference. An application must target Android O or higher and declare permission\n Manifest.permission.REQUEST_INSTALL_PACKAGES in order to use this API."}]